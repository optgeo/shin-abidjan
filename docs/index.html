<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Abidjan 2019 PMTiles Viewer</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .toolbar {
      position: absolute; z-index: 1; top: 10px; left: 10px;
      background: rgba(255,255,255,0.92); padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      font: 14px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      max-width: 92vw;
    }
    .toolbar input { width: min(520px, 70vw); }
    .row { display: flex; gap: 6px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    .hints { font-size: 12px; color: #444; margin-top: 6px; }
    .links { margin-top: 4px; font-size: 12px; }
    .links a { margin-right: 8px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="toolbar">
    <div class="row">
      <strong>Abidjan 2019 ラスタ表示</strong>
    </div>
    <div class="row">
      <label for="tilejsonInput">TileJSON URL:</label>
      <input id="tilejsonInput" placeholder="https://tunnel.optgeo.org/martin/abidjan-2019" />
      <button id="loadTilejson">Load</button>
    </div>
    <div class="row">
      <label for="pmtilesInput">PMTiles URL:</label>
      <input id="pmtilesInput" placeholder="https://tunnel.optgeo.org/abidjan-2019.pmtiles" />
      <button id="loadPmtiles">Load</button>
    </div>
    <div class="hints">
      - 既定は TileJSON を使用。PMTiles 直接参照も可能（HTTPS + CORS + Range 必須）。<br/>
      - クエリ指定例: <code>?tilejson=https://tunnel.optgeo.org/martin/abidjan-2019</code>
        または <code>?pmtiles=https://tunnel.optgeo.org/abidjan-2019.pmtiles</code>
    </div>
    <div class="links">
      Quick Links:
      <a href="?tilejson=https://tunnel.optgeo.org/martin/abidjan-2019">TileJSONを読み込む</a>
      <a href="?pmtiles=https://tunnel.optgeo.org/abidjan-2019.pmtiles">PMTilesを読み込む</a>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
  <script>
    // 地図初期化（Abidjan 近辺）
    const map = new maplibregl.Map({
      container: 'map',
      style: { version: 8, sources: {}, layers: [] },
      center: [-4.01, 5.34],
      zoom: 11,
      maxZoom: 22
    });
    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');

    // pmtiles プロトコル登録
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);

    // MapLibre はスタイル読込完了前に addSource/addLayer するとエラーになるため、
    // すべての addSource 系は load 後に実行する。
    function whenLoaded(fn) {
      if (map.isStyleLoaded && map.isStyleLoaded()) {
        fn();
      } else {
        map.once('load', fn);
      }
    }

    // 既存レイヤ/ソースを除去
    function resetSource(id) {
      if (map.getLayer(id)) map.removeLayer(id);
      if (map.getSource(id)) map.removeSource(id);
    }

    // タイルの境界に合わせてフィット（TileJSON想定）
    async function fitFromTileJSON(url) {
      try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) return;
        const tj = await res.json();
        if (tj && Array.isArray(tj.bounds) && tj.bounds.length === 4) {
          const [w,s,e,n] = tj.bounds;
          map.fitBounds([[w, s], [e, n]], { padding: 20, maxZoom: tj.maxzoom ?? 19 });
        } else if (tj && Array.isArray(tj.center) && tj.center.length >= 2) {
          map.setCenter([tj.center[0], tj.center[1]]);
          if (typeof tj.center[2] === 'number') map.setZoom(tj.center[2]);
        }
      } catch (e) {
        // 失敗しても致命的ではないので黙って続行
      }
    }

    // WebP 対応可否を非同期判定
    const webpSupportPromise = (function testWebP(){
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img.width > 0 && img.height > 0);
        img.onerror = () => resolve(false);
        // 2x1 の最小 WebP 画像（lossy）
        img.src = 'data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICAAAABwAgCdASoEAAQAAVAfJZACdLoAAP7/AA=='
      });
    })();

    async function setRasterFromTileJSON(tilejsonUrl, opts = {}) {
      const id = 'abidjan-raster';
      resetSource(id);

      let tj; // 取得した TileJSON
      try {
        const res = await fetch(tilejsonUrl, { mode: 'cors' });
        tj = await res.json();
      } catch (e) {
        console.error('Failed to fetch TileJSON:', tilejsonUrl, e);
        return;
      }

      // tiles 配列が存在しない場合は url 指定にフォールバック
      const hasTiles = tj && Array.isArray(tj.tiles) && tj.tiles.length > 0;

      // WebP 非対応ブラウザでは .webp -> .png 差し替え（サーバ側がPNG対応している前提）
      const webpOk = await webpSupportPromise;
      let tiles = hasTiles ? [...tj.tiles] : null;
      if (tiles && !webpOk) {
        tiles = tiles.map(u => u.replace(/\.webp(\b|$)/i, '.png'));
      }

      const sourceDef = hasTiles
        ? { type: 'raster', tiles, tileSize: tj.tileSize || tj.tile_size || 512, attribution: tj.attribution }
        : { type: 'raster', url: tilejsonUrl };

      whenLoaded(() => {
        map.addSource(id, sourceDef);
        map.addLayer({ id, type: 'raster', source: id });
        map.setMaxZoom(opts.maxZoom ?? (tj.maxzoom ?? 19));
      });

      // フィット（可能なら TileJSON の bounds/center）
      fitFromTileJSON(tilejsonUrl);
    }

    function setRasterFromPMTiles(url, opts = {}) {
      const id = 'abidjan-raster';
      resetSource(id);
      // キャッシュ向上: 事前に PMTiles インスタンスを登録
      protocol.add(new pmtiles.PMTiles(url));
      // pmtiles:// を URL として指定すると TileJSON が解決される
      map.addSource(id, {
        type: 'raster',
        url: `pmtiles://${url}`,
        tileSize: 512
      });
      map.addLayer({ id, type: 'raster', source: id });
      map.setMaxZoom(opts.maxZoom ?? 19);
      // PMTiles メタからのフィットは簡易化のため省略（必要なら拡張可能）
    }

    // エラーイベントを拾って、失敗URLなどの手がかりを出力
    map.on('error', (e) => {
      // MapLibre は image decode 失敗時などに汎用エラーを出すため、手がかりをまとめて出力
      console.warn('Map error:', e && e.error ? e.error : e);
    });

    // クエリパラメータ対応
    const params = new URLSearchParams(location.search);
    const defaultTileJSON = 'https://tunnel.optgeo.org/martin/abidjan-2019';
    const defaultPMTiles = 'https://tunnel.optgeo.org/abidjan-2019.pmtiles';
    const tilejsonUrl = params.get('tilejson') || defaultTileJSON;
    const pmtilesUrl = params.get('pmtiles');

    const tilejsonInput = document.getElementById('tilejsonInput');
    const pmtilesInput = document.getElementById('pmtilesInput');
    const loadTilejsonBtn = document.getElementById('loadTilejson');
    const loadPmtilesBtn = document.getElementById('loadPmtiles');

    // 入力欄に既定値をセット
    tilejsonInput.value = tilejsonUrl;
    pmtilesInput.value = pmtilesUrl || defaultPMTiles;

    // 初期ロードは style load 後に実行
    whenLoaded(() => {
      // 既定は TileJSON をロード
      setRasterFromTileJSON(tilejsonUrl);
      // 明示的に pmtiles= が来ていたら PMTiles を優先適用（上書き）
      if (pmtilesUrl) setRasterFromPMTiles(pmtilesUrl);
    });

    // ボタン操作も style load 後に実行
    loadTilejsonBtn.onclick = () => {
      const url = tilejsonInput.value.trim();
      if (url) whenLoaded(() => setRasterFromTileJSON(url));
    };
    loadPmtilesBtn.onclick = () => {
      const url = pmtilesInput.value.trim();
      if (url) whenLoaded(() => setRasterFromPMTiles(url));
    };
  </script>
</body>
</html>
