<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Abidjan 2019 PMTiles Viewer</title>
  <link href="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .toolbar {
      position: absolute; z-index: 1; top: 10px; left: 10px;
      background: rgba(255,255,255,0.92); padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      font: 14px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      max-width: 92vw;
    }
    .toolbar input { width: min(520px, 70vw); }
    .row { display: flex; gap: 6px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    .hints { font-size: 12px; color: #444; margin-top: 6px; }
    .links { margin-top: 4px; font-size: 12px; }
    .links a { margin-right: 8px; }
    .small-btn { cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; padding: 2px 8px; }
    .panel-header { display: flex; align-items: center; gap: 8px; }
    .toggle { cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; padding: 2px 6px; }
    .toolbar.minimized .panel-body { display: none; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="toolbar minimized" id="panel">
    <div class="panel-header row">
      <button id="togglePanel" class="toggle" aria-expanded="false" title="設定を表示/隠す">▶</button>
      <strong>Imagery PMTiles Viewer</strong>
      <span style="flex:1 1 auto"></span>
    </div>
    <div class="panel-body">
    <div class="row">
      <label for="tilejsonInput">TileJSON URL:</label>
      <input id="tilejsonInput" placeholder="https://tunnel.optgeo.org/martin/abidjan-2019" />
      <button id="loadTilejson">Load</button>
    </div>
    <div class="row">
      <label for="pmtilesInput">PMTiles URL:</label>
      <input id="pmtilesInput" placeholder="https://tunnel.optgeo.org/abidjan-2019.pmtiles" />
      <button id="loadPmtiles">Load</button>
    </div>
    <div class="hints">
      - 既定は TileJSON を使用。PMTiles 直接参照も可能（HTTPS + CORS + Range 必須）。<br/>
      - クエリ指定例: <code>?tilejson=https://tunnel.optgeo.org/martin/abidjan-2019</code>
        または <code>?pmtiles=https://tunnel.optgeo.org/abidjan-2019.pmtiles</code>
    </div>
    <div class="links">
      Quick Links:
      <a href="?tilejson=https://tunnel.optgeo.org/martin/abidjan-2019">TileJSONを読み込む</a>
      <a href="?pmtiles=https://tunnel.optgeo.org/abidjan-2019.pmtiles">PMTilesを読み込む</a>
    </div>
    </div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.js"></script>
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>
  <script>
    // 地図初期化（Abidjan 近辺）
    const map = new maplibregl.Map({
      container: 'map',
      style: { version: 8, sources: {}, layers: [], glyphs: 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf' },
      center: [-4.01, 5.34],
      zoom: 11,
      maxZoom: 20,
      hash: true
    });
    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), 'top-right');
    // Geolocation control
    const geolocateControl = new maplibregl.GeolocateControl({
      positionOptions: { enableHighAccuracy: true },
      trackUserLocation: false,
      showUserLocation: true
    });
    map.addControl(geolocateControl, 'top-right');
    // Globe control (if available). Fallback to ProjectionControl if GlobeControl is unavailable.
    if (typeof maplibregl.GlobeControl === 'function') {
      map.addControl(new maplibregl.GlobeControl(), 'top-right');
    } else if (typeof maplibregl.ProjectionControl === 'function') {
      try {
        map.addControl(new maplibregl.ProjectionControl({ projections: ['mercator', 'globe'] }), 'top-right');
      } catch (e) {
        console.warn('ProjectionControl add failed:', e);
      }
    }

    // pmtiles プロトコル登録
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol('pmtiles', protocol.tile);

    // MapLibre はスタイル読込完了前に addSource/addLayer するとエラーになるため、
    // すべての addSource 系は load 後に実行する。
    function whenLoaded(fn) {
      if (map.isStyleLoaded && map.isStyleLoaded()) {
        fn();
      } else {
        map.once('load', fn);
      }
    }

    // オーバーレイレイヤの ID 一覧
    const OVERLAY_LAYER_IDS = ['proto-place-labels', 'proto-poi-labels'];

    // ラスタを常にオーバーレイ（ラベル）より下に入れるヘルパー
    function addRasterSourceAndLayer(id, sourceDef, opts = {}) {
      try {
        map.addSource(id, sourceDef);
      } catch (e) {
        console.warn('addSource failed:', e);
        return false;
      }
      try {
        const beforeId = OVERLAY_LAYER_IDS.find(lid => map.getLayer(lid));
        map.addLayer({ id, type: 'raster', source: id }, beforeId);
      } catch (e) {
        console.warn('addLayer failed:', e);
        return false;
      }
      map.setMaxZoom(opts.maxZoom ?? 20);
      return true;
    }

    // 既存レイヤ/ソースを除去
    function resetSource(id) {
      if (map.getLayer(id)) map.removeLayer(id);
      if (map.getSource(id)) map.removeSource(id);
    }

    // タイルの境界に合わせてフィット（TileJSON想定）
    async function fitFromTileJSON(url) {
      try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) return;
        const tj = await res.json();
        if (tj && Array.isArray(tj.bounds) && tj.bounds.length === 4) {
          const [w,s,e,n] = tj.bounds;
          map.fitBounds([[w, s], [e, n]], { padding: 20, maxZoom: Math.min(20, tj.maxzoom ?? 20) });
        } else if (tj && Array.isArray(tj.center) && tj.center.length >= 2) {
          map.setCenter([tj.center[0], tj.center[1]]);
          if (typeof tj.center[2] === 'number') map.setZoom(tj.center[2]);
        }
      } catch (e) {
        // 失敗しても致命的ではないので黙って続行
      }
    }

    // WebP 対応可否を非同期判定
    const webpSupportPromise = (function testWebP(){
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img.width > 0 && img.height > 0);
        img.onerror = () => resolve(false);
        // 2x1 の最小 WebP 画像（lossy）
        img.src = 'data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICAAAABwAgCdASoEAAQAAVAfJZACdLoAAP7/AA=='
      });
    })();

    async function setRasterFromTileJSON(tilejsonUrl, opts = {}) {
      const id = 'abidjan-raster';
      resetSource(id);

      let tj; // 取得した TileJSON
      try {
        const res = await fetch(tilejsonUrl, { mode: 'cors' });
        tj = await res.json();
      } catch (e) {
        console.error('Failed to fetch TileJSON:', tilejsonUrl, e);
        return;
      }

      // tiles 配列が存在しない場合は url 指定にフォールバック
      const hasTiles = tj && Array.isArray(tj.tiles) && tj.tiles.length > 0;

      // WebP 非対応ブラウザでは .webp -> .png 差し替え（サーバ側がPNG対応している前提）
      const webpOk = await webpSupportPromise;
      let tiles = hasTiles ? [...tj.tiles] : null;
      if (tiles && !webpOk) {
        tiles = tiles.map(u => u.replace(/\.webp(\b|$)/i, '.png'));
      }

      const sourceDef = hasTiles
        ? {
            type: 'raster',
            tiles,
            tileSize: tj.tileSize || tj.tile_size || 512,
            minzoom: typeof tj.minzoom === 'number' ? tj.minzoom : 0,
            maxzoom: typeof tj.maxzoom === 'number' ? tj.maxzoom : 22
          }
        : { type: 'raster', url: tilejsonUrl };
      // attribution が null/undefined の場合に key 自体を付与しない
      if (typeof tj?.attribution === 'string' && tj.attribution.trim().length > 0) {
        sourceDef.attribution = tj.attribution;
      }

      whenLoaded(() => {
        addRasterSourceAndLayer(id, sourceDef, opts);
      });

      // フィット（可能なら TileJSON の bounds/center）
      if (!(location.hash && location.hash.length > 1)) {
        fitFromTileJSON(tilejsonUrl);
      }
    }

    function setRasterFromPMTiles(url, opts = {}) {
      const id = 'abidjan-raster';
      resetSource(id);
      // キャッシュ向上: 事前に PMTiles インスタンスを登録
      protocol.add(new pmtiles.PMTiles(url));
      // pmtiles:// を URL として指定すると TileJSON が解決される
      addRasterSourceAndLayer(id, {
        type: 'raster',
        url: `pmtiles://${url}`,
        tileSize: 512
      }, opts);
      // PMTiles メタからのフィットは簡易化のため省略（必要なら拡張可能）
    }

    // エラーイベントを拾って、失敗URLなどの手がかりを出力
    map.on('error', (e) => {
      // MapLibre は image decode 失敗時などに汎用エラーを出すため、手がかりをまとめて出力
      console.warn('Map error:', e && e.error ? e.error : e);
    });

  // クエリパラメータ対応
  const params = new URLSearchParams(location.search);
    const defaultTileJSON = 'https://tunnel.optgeo.org/martin/abidjan-2019';
    const defaultPMTiles = 'https://tunnel.optgeo.org/abidjan-2019.pmtiles';
    const tilejsonUrl = params.get('tilejson') || defaultTileJSON;
    const pmtilesUrl = params.get('pmtiles');
    const rawProtomaps = params.get('protomaps');
    const defaultProtomaps = 'https://tunnel.optgeo.org/martin/protomaps-basemap';
    const protomapsUrl = (rawProtomaps === 'none') ? null : (rawProtomaps || defaultProtomaps);

    const tilejsonInput = document.getElementById('tilejsonInput');
    const pmtilesInput = document.getElementById('pmtilesInput');
    const loadTilejsonBtn = document.getElementById('loadTilejson');
    const loadPmtilesBtn = document.getElementById('loadPmtiles');

    // パネルの折りたたみ制御（起動時は最小化）
  const panel = document.getElementById('panel');
  const toggleBtn = document.getElementById('togglePanel');
    function setPanelExpanded(expanded) {
      panel.classList.toggle('minimized', !expanded);
      toggleBtn.textContent = expanded ? '▼' : '▶';
      toggleBtn.setAttribute('aria-expanded', String(expanded));
    }
    setPanelExpanded(false);
    toggleBtn.onclick = () => {
      const next = toggleBtn.getAttribute('aria-expanded') !== 'true';
      setPanelExpanded(next);
    };

    // 独自の現在地/Globe ボタンは廃止（標準コントロールを使用）

    // 入力欄に既定値をセット
    tilejsonInput.value = tilejsonUrl;
    pmtilesInput.value = pmtilesUrl || defaultPMTiles;

    // 初期ロードは style load 後に実行
    whenLoaded(() => {
      // 既定は TileJSON をロード
      setRasterFromTileJSON(tilejsonUrl);
      // 明示的に pmtiles= が来ていたら PMTiles を優先適用（上書き）
      if (pmtilesUrl) setRasterFromPMTiles(pmtilesUrl);
      // Protomaps オーバーレイ（低ズーム: 地名ラベル / 高ズーム: POI）
      if (protomapsUrl) addProtomapsOverlay(protomapsUrl);
    });

    // ボタン操作も style load 後に実行
    loadTilejsonBtn.onclick = () => {
      const url = tilejsonInput.value.trim();
      if (url) whenLoaded(() => setRasterFromTileJSON(url));
    };
    loadPmtilesBtn.onclick = () => {
      const url = pmtilesInput.value.trim();
      if (url) whenLoaded(() => setRasterFromPMTiles(url));
    };
    
    // Protomaps ベースマップの最小オーバーレイ: 低ズーム=地名ラベル, 高ズーム=POI
    async function addProtomapsOverlay(tilejsonUrl) {
      const sourceId = 'proto';
      try {
        const res = await fetch(tilejsonUrl, { mode: 'cors' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const tj = await res.json();

  // 既存のレイヤを先に消す
  OVERLAY_LAYER_IDS.forEach(lid => { if (map.getLayer(lid)) try{ map.removeLayer(lid); } catch{} });
  if (map.getSource(sourceId)) map.removeSource(sourceId);

        const sourceDef = { type: 'vector', url: tilejsonUrl };
        if (typeof tj?.attribution === 'string' && tj.attribution.trim()) {
          sourceDef.attribution = tj.attribution;
        }

        whenLoaded(() => {
          try { map.addSource(sourceId, sourceDef); } catch {}

          const vecLayers = Array.isArray(tj.vector_layers) ? tj.vector_layers : [];
          const findLayerId = (keywords) => {
            const lower = (s) => (s || '').toLowerCase();
            const hit = vecLayers.find(l => keywords.some(k => lower(l.id).includes(k)));
            return hit && hit.id;
          };

          const lyrPlaces = findLayerId(['place','places','label']);
          const lyrPoi    = findLayerId(['poi','pois','amenity']);

          // 地名ラベル（低ズーム向け）: テキスト小さめ、出現ズーム+2
          if (lyrPlaces) {
            try {
              map.addLayer({
                id: 'proto-place-labels',
                type: 'symbol',
                source: sourceId,
                'source-layer': lyrPlaces,
                layout: {
                  'text-field': ['coalesce', ['get','name:ja'], ['get','name:en'], ['get','name']],
                  'text-size': ['interpolate', ['linear'], ['zoom'], 5, 9, 8, 11, 12, 13, 14, 15],
                  'text-allow-overlap': false,
                  'visibility': 'visible'
                },
                paint: {
                  'text-color': '#ffffff',
                  'text-halo-color': 'rgba(0,0,0,0.85)',
                  'text-halo-width': 1.2
                },
                minzoom: 5,
                maxzoom: 15
              });
            } catch (e) { console.warn('add place labels failed', e); }
          }

          // POI ラベル（高ズーム向け）: テキスト小さめ、出現ズーム+2
          if (lyrPoi) {
            try {
              map.addLayer({
                id: 'proto-poi-labels',
                type: 'symbol',
                source: sourceId,
                'source-layer': lyrPoi,
                layout: {
                  'text-field': ['coalesce', ['get','name:ja'], ['get','name:en'], ['get','name']],
                  'text-size': ['interpolate', ['linear'], ['zoom'], 16, 10, 18, 12, 20, 14],
                  'text-allow-overlap': false,
                  'visibility': 'visible'
                },
                paint: {
                  'text-color': '#eeeeee',
                  'text-halo-color': 'rgba(0,0,0,0.9)',
                  'text-halo-width': 1.2
                },
                minzoom: 16
              });
            } catch (e) { console.warn('add poi labels failed', e); }
          }
        });
      } catch (e) {
        console.warn('Protomaps overlay load failed:', e);
      }
    }
  </script>
</body>
</html>
